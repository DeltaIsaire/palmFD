# Author's Log
This is my daily log of activities and notes related to this project.


## Monday november 12, 2018

Start of Author's Log.
Jun suggested to keep a daily log of all my activities on the palm FD project, as a way to keep track of all the files and code I will be producing. That's a great idea, so let's do this.

Met up with Jun this morning to discuss method details. We talked mostly about gap-filling the palm trait data. Goal for this week should be getting trait-filling code to work, at least on a basic level.
Monday-morning meetup with Jun will likely become a weekly thing (Mondays 10am).

Re-organized my code and data files. 
All input and output data files are kept in my R projects folder, ~/R_Projects/Palm_FD.
All code is kept inside one folder within the palm FD folder:~/R_Projects/Palm_FD/code.
Your standard R working directory should therefore be
setwd("/home/delta/R_Projects/Palm_FD")

I have not set up github yet, but I can see that becoming a thing.

Structure of code filing:
For every project step, such as trait-filling, I will create a parent codefile in /R_code (e.g. trait_filling.R). This file contains the executive code for this step.
Any functions created for the process will have their code in a seperate file under R_code/functions. These functions are called in the parent codefile, which should also load them with the source() function.
see also https://nicercode.github.io/guides/functions/

So today I'm learning about functions.
In fact, I'm going to take a few hours today reading some of the guides on https://nicercode.github.io/, because it's a great introduction to getting your hands dirty in R, and I need that introduction.
And also https://arxiv.org/pdf/1210.0530.pdf (downloaded, see code/supporting_documents).
I also vow to abide to Google's R Style Guide: https://google.github.io/styleguide/Rguide.xml (downloaded, see code/supporting_documents).

I should totally set up git / github, for version control and code communication.


## Tuesday November 13, 2018
This morning I studied how Git works, and set up a repository for the project:
https://github.com/DeltaIsaire/palmFD
Now we can code properly and share the work.

Next I begin coding (a.k.a. puzzling) for trait-filling. Git will keep track of what I am doing.
I begin by cross-referencing the species in the distribution, traits and tree datafiles to see if they agree on which palm species exist, and what the discrepancies are. A good exercise in using my new coding methods...


## Wednesday November 14, 2018
A day spent coding.
I now have three complete functions: isOneDimensional, crossReference and multiCrossRef.

Subsequently I used the cross-referencing functions to compare the species listed in the palm distribution, palm traits and palm phylogenetic tree, and produced a list of the species names present in all three datasets.

Starting tomorrow I should subset the palm distribution and palm traits data to the agreed species list, and see if I can calculate genus-level means for palm traits. Removing species from the phylogenetic tree will be more difficult...


## Monday November 19, 2018
Met Jun again this morning. We discussed how to do BHPMF, in particular the use of a hierarchical matrix rather than a phylogenetic tree. 

Last week I finished the code for gap-filling with genus means.
Today I will try to get BHPMF working properly. 

Planning update:
The official starting date is 22 October 2018. I actually started working on the project one week earlier, so the unofficial starting date is 15 October 2018.
That makes today the beginning of week 6 (or officially, week 5). 
According to the planning we made, the proposal should be finished by week 6, and week 7-10 are reserved for trait filling. I spent last week on trait filling already, so there is a bit of overlap.
In conclusion, there's 2 weeks left for the proposal (re-structuring the introduction and finishing the method section), and 3 weeks for trait-filling.
Also, in week 7 or 8 there should be an interim assessment. You should plan a date for that this week. 


## Tuesday November 20, 2018
This morning I read Noble 2009: A quick guide to organizing computational biology projects. There are some useful tips in there, some of them new to me. Definitely recommended material for students like me, together with Wilson et al 2013: best practices for scientific computing. Both PDFs are stored in palm_FD/reference_literature; together with Google's R style guide. While I'm at it, I should also mention the Nice R Code blog, which is a great reference for beginning R coders: https://nicercode.github.io/

Subsequently I reorganized some files (see git log). I also split some of the non-essential testing code from the trait filling script into a seperate file (again see git log). When developing code, you will often be running all kinds of checks, and it is good to store those in a seperate file. That way the main script remains clean, but you still have some reference material available for bug-testing and the like. The general pattern is to name these reference files scriptname_test.R. So essentially, when making a script you work on two files concurrently: the script and the script_test.

The goal for today is comparing the gap-filling results obtained with genus-means and BHPMF. This involves making plots, for which I will be writing some custom plotting functions. These functions combine my best knowledge of plotting with advice from the Nice R Code blog, and will help with plotting now and in the future. First custom function is Scatterplot, cause I will be making scatterplots today.

What I ended up doing:
- wrote functions Scatterplot and GraphPDF, see palm_FD/functions/plotting.functions.R
- Made the first Scatterplot, comparing Genus mean and BHPMF estimates of stem height.

A lot of time today was spent working out making quality plotting functions. That time investment will pay off later. 


## Wednesday November 20, 2018
Today I should finish comparing the results of genus-mean gap-filling with BHPMF gap-filling.

I added the MultiScatter function, which provides a quick way to create decent quality scatterplots. Subsequently I used the function for comparing genus-mean trait predictions with BHPMF trait predictions, for our three traits stem height, blade length and fruit length.

The next task is comparing predicted trait values with boxplots. hile preparing data for making these boxplots, I found out that the BHPMF results aren't quite what they should be. The BHPMF output appears to also estimate trait values that were already known. Case in point is the palm species Eremospatha_tessmanniana.

The original data:
```
> traits[which(traits$species == "Eremospatha_tessmanniana"), ]
                      species       genus stem.height blade.length fruit.length
1413 Eremospatha_tessmanniana Eremospatha         150          0.8           NA
```
Data filled with BHPMF:
```
> traits.BHPMF[which(traits.BHPMF$species == "Eremospatha_tessmanniana"), ]
                      species       genus stem.height blade.length fruit.length
1209 Eremospatha_tessmanniana Eremospatha     47.3923        0.803       2.4764
```

In hindsight, I could have known. The description of the BHPMF::GapFilling function says "Will save the mean and standard deviations (uncertainties) of the predictions for both missing and observed values into the given file paths."

That's all very well, but it might not be what we need. We should probably assume that the observed values are 'correct' and do not need to be predicted. Then instead of taking the BHPMF output as-is, we should extract only the predicted values for trait values which were missing. In theory that's easy enough, relatively speaking.

I have implemented this. In practice it wasn't entirely straightforward. It involved updating my custom GapFill function to handle the case where the 'by' column in the two provided dataframes is a factor, with differing levels between the datasets. And also, bugfix the gapfilling routine: I replaced an unlist() with as.numeric(). And then of course I had to check if everything now works as intended, which thankfully it does. 


## Friday November 23, 2018
Yesterday I emailed my daily supervisor with some questions about BHPMF and the inputs/outputs used in the process. Now it's time to get our hands dirty and see if we can make this work. 

Yesterday I already started playing around with the inputs of the BHPMF GapFilling function. There are a few issues to work out. Specifically:
- BHPMF got stuck in an infinite loop if some observed trait values are exactly 0
	Tested solution: set these values to a small non-zero value.
- BHPMF doesn't work if a species has NA for all included traits, even if only one column of trait values (i.e. only a single trait) is provided as input.
	Tested solutions: remove these species, include a dummy trait with all values 1.
All the test code is in '1_trait_filling_test.R'

Today I continue testing, and the goal is to report outcomes as well as comparisons of outputs between different BHPMF attemps and with Genus-Mean gap-filling.

First I run a series of BHPMF Gap-filling with different inputs:
```
From 1_trait_filling.test.R:
We begin with the base unimputed trait matrix, which has a single 'oberved'
trait value for each species, with gaps (NAs).
The main script generates:
1. Matrix gap-filled using genus means.
2. Matrix gap-filled using BHPMF with our three traits of interest, extracting
   from the BHPMF output only the estimates for the gaps in the original matrix.
Here, we generate:
3. Matrix gap-filled using BHPMF with our three traits of interest,
   using the full output of BHPMF (including estimates of 'observed' trait data)
4. Same as #2, but including a fourth dummy trait, with all values = 1
5. Same as #2, but including the following additional traits:
   MaxStemDia_cm, MaxLeafNumber, Max_Rachis_Length_m, Max_Petiole_length_m,
   AverageFruitWidth_cm
```
The next thing to do is comparing the outputs of these five gap-filling attempts. The code for that will be in 2_trait_filling_comparison_test.R, and I'm making a document trait_filling_comparison.docx as an update. To import graphs into a writer document it is best to export as SVG rather than PDF, so I made a custom GraphSVG function first. UPDATE: I might end up using SVGs from now on, cause they're way more awesome than PDFs.

At the end of the day I have some neat combined boxplots, comparing for each
trait the estimated values for each of the five methods. 

## Monday November 26, 2018
This morning I quickly finished making comparison graphs, mostly scatterplots comparing gap-filling method two (standard BHPMF) with the four other methods, for each trait. Subsequently I met up with my daily supervisor again to discuss gap-filling methods. 

Some observations:
For our purposes, boxplots really aren't that informative. Maybe histograms would be better. Then again, we should just move on.
For the comparisons, it looks like there is no strong bias for any of the five methods, i.e. the results make sense, variation is symmetric, et cetera.

There was one strange outlier value in method three. Let's investigate:
```
# Original data:
> traits[which(traits$species == "Nypa_fruticans"), ]
            species genus stem.height blade.length fruit.length
1954 Nypa_fruticans  Nypa           0         10.2         11.5
# Input to method three:
> trait.matrix[which(rownames(trait.matrix) == "Nypa_fruticans"), ]
 stem.height blade.length fruit.length 
      0.0001      10.2000      11.5000
> hierarchy.matrix[which(hierarchy.matrix[, 2] == "Nypa"), ]
         species            genus            tribe        subfamily 
"Nypa_fruticans"           "Nypa"      "Nypoideae"      "Nypoideae"
> hierarchy.matrix[which(hierarchy.matrix[, 3] == "Nypoideae"), ]
         species            genus            tribe        subfamily 
"Nypa_fruticans"           "Nypa"      "Nypoideae"      "Nypoideae" 
> hierarchy.matrix[which(hierarchy.matrix[, 4] == "Nypoideae"), ]
         species            genus            tribe        subfamily 
"Nypa_fruticans"           "Nypa"      "Nypoideae"      "Nypoideae" 
# Result of method three:
> filled.three[which(filled.three$species == "Nypa_fruticans"), ]
            species genus stem.height blade.length fruit.length
1697 Nypa_fruticans  Nypa     -0.0017     -47.1934      11.5002
> test.std[which(test.std$species == "Nypa_fruticans"), ]
            species genus stem.height blade.length fruit.length
1697 Nypa_fruticans  Nypa      0.0955      19.3328       0.0966
```
That estimated blade length value is weird. The uncertainty (stdev) in that blade length estimate is also huge. From the input, we can see it is the only species in its genus, tribe and subfamily, interestingly enough.



There are three things I should look into now:
1) Explicitly compare BHPMF estimates for 'known' values with those known values.
2) To get the fullest coverage, we can combine BHPMF with genus-means. There are two ways to do that: taking genus means from the original 'known' values, or taking genus means from the known + BHMPMF estimated values. These two methods will have to be compared.
3) Compare the use of 1 dummy trait with using 5 dummy traits, to assess how using dummies influences the output.
And also, if there is time, you can divide the data into training and test subsets (95% vs 5% of data points), to assess how accurate the gap-filling methods are.

Aside from gap-filling, there is writing to consider. As inspired by a Science mag article my assessor linked us (DOI: 10.1126/science.353.6300.718), I'm going to spend the first hour of my working days on the writing. Starting tomorrow morning.

Update:
I finished 1). Turns out the BHPMF estimates for 'observed' values can differ substantially from those observed values. Moreover, there is an asymmetrical trend: the higher the observed trait value, the lower the estimated trait value tends to be. All three traits show this pattern, but it is most pronounced for stem height.

Update: I finished 3). It looks like adding dummy variables does not introduce bias in the trait value estimates. But does this workaround provide accurate results for those species where BHPMF normally does not work? It seems so. Gap-filling using BHPMF with a dummy trait is a serious option to consider. 

## Wednesday November 28, 2018
It's maintenance day: I am reviewing my code formatting and comment structure and checking if my scripts and stuff need to be reorganized. I have taken some tips from the Tidyverse style guide (https://style.tidyverse.org), and I'm rewriting my code to use piping operators from package magrittr. Once again I wonder why the master's course in data analysis never took a few days to teach the students how to actually code properly in R. Piping makes code way easier to read, and actually makes coding easier and less confusing as well.

Current situation:
Different gap-filling methods are implemented in test_1_trait_filling.R;
and these are compared in test_2_trait_filling_comparison.R.
The main trait filling script is where the best/chosen trait filling method will be implemented. Consider that script a placeholder for the moment.

## Wednesday December 5, 2018
Maintenance day became maintenance week. I ended up reading "The R Inferno" by Patrick Burns, which is a very well-written guide to avoiding common mistakes in R. There's a lot of basic things in there that an R coder should be aware of. So anyway, I completely revised all my code.

Subsequently I finished comparing gapfilling methods, and additionally assessed the accuracy of gapfilling via the use of an artificially sparse subset of our trait data. All the significant details and main outcomes are reported in the update document trait_filling_comparison.docx.

Yesterday was the interim assessment of my project. Things are going pretty well, actually. We discussed my trait-filling comparisons. One of the main outcomes of that discussion was to try BHPMF, with 'growthform' added as an extra hierarchy level in between genus and species. I have implemented this today. (The other outcome is that I can be more vocal / quicker to ask questions to my supervisor. Independence is great, but don't hesitate to get dependent!).

For 54 species, there is no unambiguous growth form information, so I had to classify their growthform as NA, and remove these species from the BHPMF input data. Between NAs for growthform and NAs for all three trait values, the ultimate input matrix for this BHPMF trial had 2204 species (out of 2557).

But, surprise: the trait matrix gap-filled with this output has 2238 species! A mistake? No, I checked. It looks like magic, but it's not. What happens is that many of the species with NA for growthform actually have 100% complete trait information. So, while their traits could not be estimated, there was no need to estimate those traits either! Sometimes you're lucky.

Subsequently I include the 'growthform BHPMF' method in the test traitfilling comparisons.
Findings re accuracy:
All the ANOVAs of the estimates are still not significant, so growthform BHPMF is as accurate as the other methods. 
I made Scatterplots of standard BHPMF vs growthform BHPMF. It looks like the correlation is still very much there, but there is more residual variation (higher R^2, although I am eyeballing it rather than calculating R^2)

A much more interesting accuracy comparison is the following:
For each trait, plot the original values vs the estimates from standard BHPMF and growthform BHPMF. In other words, a combined plot with 6 frames in 3 columns, where each column is a trait and each row a method.

Didn't finish it today, but it looks like growthform BHPMF isn't that much better.

## Friday December 7, 2018
Growthform BHPMF is not all that different from standard BHPMF, so I wouldn't call it better. 

There are two things we could try. First would be including even more trait information in BHPMF: one of my supervisors suggested we can get away with using binary categorical trait variables.

The second option would be assessing the estimate uncertainty (BHPMF outputs standard deviations for each estimate) and selecting only those estimates with a reasonably low uncertainty.

It seems to me that the latter is most likely to improve accuracy. But maybe we can use the combination of both. Let's go for the complete overkill and include all traits as can possibly be included, and then look at the uncertainties.

Update: my daily supervisor said not to look at the uncertainties but focus on including the categorical growthform traits. So I am focusing on two new BHPMF methods now: 7a with the 3 main traits + 3 binary growthform traits, and 7b which includes all usable traits, continuous and binary. Results will be reported in word doc format as before.
Update: this was done.

## Monday December 10, 2018
Planning update: 
The official starting date is 22 October 2018. I actually started working on the project one week earlier, so the unofficial starting date is 15 October 2018. That makes today the beginning of week 10. According to our initial planning, at the end of week ten we should have trait gap-filling finished, and have a finished research proposal.

The last two weeks we have been mucking around with BHPMF. It really is time to wrap that up. Also, I need to sit down to finish my research proposal THIS WEEK. Finally, it is time to look forward towards FD calculation. Weeks 11-14 are for computing FD indices for palm communities at the level of botanical countries.

This afternoon is the weekly discussion with my daily supervisor. We should talk about wrapping up BHPMF / gap-filling and then start looking at FD calculation. My main questions about FD are about the use of null models - how they work fundamentally and which ones we should try.

Notes of meeting with daily supervisor:
```
Using Genus Means might be best, because BHPMF does not appear to be sufficiently reliable/accurate. Or rather, I should say it isn't more accurate than genus means for our data.

"i.i.d." can be a solution for dealing with gap-filling uncertainty.
Issue with it:
You cannot do model selection 1000 times, so summarize the input for those models:
like the FD indices.
>>> something something Z-scores
First, get the code working properly without i.i.d. Then if there is time, you could think about doing it.

Test inclusion/exclusion of missing species: run the entire analysis with (1) gap-filled trait data, and (2) with only the complete data (i.e. complete.cases(trait.matrix)). Maybe gapfilling is not necessary.

TEST YOUR CODE:
use artificial data to check if the genus-mean gap-filling code is working PROPERLY.
```

That last one is the rub. What we see in the gap-filling accuracy test with artificially sparse data, is a fairly consistent negative correlation between the original trait value and the estimated trait value. For genus means as well as BHPMF. This is weird, so we have to be absolutely 100% sure that our code is working properly.

So the first thing for me to do, is verify my gap-filling code.
One trick is to use an artificial dataset as input, where you know the structure of the data and can figure out a priori what the output of the gap-filling should look like.


Our FD shopping list:
- FD calculation requires more species than traits (S > T) so we can only use palm communities wtih 4 or more species.
- Trait data should be log-transformed to be more normal.
- Trait data should SUBSEQUENTLY be standardized to mean 0 and unit variance (SD).
- Consider comparing transformed vs un-transformed FD calculation.
- We will calculate Functional Richness (FRic) and Functional Dispersion (FDisp). This can be done with R package FD, using function 'dbFD'.

Function FD::dbFD requires the following input:
	Data:
+ Argument x: Trait matrix (or dataframe) with traits and species labels. Can be a single trait. NAs are tolerated, but figure out how those are dealt with. >>> Without NAs it uses Euclidean distance matrix, with NAs it uses a Gower dissimilarity matrix. The former is probably preferred, but you could compare them.
Given a single trait, dbFD will calculate FRic as the range; and FDisp will be calculated as normal.
+ Argument a: Presence/Absence matrix where rows are sites and species are columns.
	Settings:
+ Argument stand.x: the dbFD function can automatically perform standardization.
+ be aware of argument corr
+ Argument calc.FRic: use TRUE cause we want this.
+ Argument m: probably use 'max'
+ stand.FRic: Should FRic be standardized to the global volume? This is a non-trivial question to debate. 
+ calc.CWM: Calculate community-weighted means of trait values? Can be useful.
+ calc.FDiv: set to TRUE cause we want this

Comparing FDs between communities is where null models come into play. Something about species pools. For instance, 'consider observed values relative to those expected at random (Villéger et al 2008). You could sample randomly from the species pool the same number of species as are in the community (see Lamanna et al 2014). Sampling without replacement of course. 

Also investigate single-trait diversity! Figure out how to do that. (range, variance, etc) The dbFD function could be used to return single-trait FD, if that's what you want. 

## Monday, December 17, 2018
Oh boy, I haven't been very good at keeping logs this week... Blame it on my scheduling freedom. Which totally fits my process btw, but it can make updates erratic. Good thing my memory is decent. And hey, at least I'm writing stuff down now.

Last week following the meeting with my daily supervisor, I verified my gap-filling code (only for genus means, but BHPMF is 99% the same and I found the 'problem' so it's OK). There was no mistake in my coding. Everything was working as intended. The 'problem' then was a mismatch between our expectations and harsh reality. Tuesday I emailed my supervisor with a short report:

```
Here is what I have found. The first script tests my genus-mean gapfilling code, which has no errors in it. Feel free to verify that.
The second script reproduces the estimate error with artificial data and visualizes it.

The error we're seeing is the result of the estimates being skewed towards the mean of the data (with genus means the estimate IS the mean; but it happens with BHPMF as well). In the case of genus means:
Estimate == genus mean
When an original value is > the genus mean, the estimate is too low.
When an original value is < the genus mean, the estimate is too high.
In general, the error is (genus mean - x) where x is the original value.
The higher the variance in the original data, the larger the error will be.

The included graph visualizes original vs mean estimates for two genera.
The original data are 100 samples per genus from a normal distribution, with random gaps added for 30% of values.
For genus A: mean = 2, sd = 0.5. For genus B: mean = 4, sd = 2.
The residuals plot (frame B) clearly shows that the error follows (mean - x) for each genus.

Dealing with this error could be tricky. This i.i.d. you mentioned yesterday might help.
```
And the response:
```
Really really good work! Sorry for the slow response, I was a little busy yesterday.

I had not thought about the fact the observed value itself IS correlated with the filled value. So that would mean that what we’re seeing is really multiple parallel straight lines with intercepts equal to the genus level means. Now you see the power of simulated data!

If that’s the case, then the only way to gauge if the method is good is to make sure that the residuals at least are normally distributed (i.e., they are random with respect to their original fitted value).

I really like to know if there are strong bimodalities are especially problematic for stem height in genera with multiple growth forms, and whether that has any impact on the data.

But I think you should be comfortable going away with calculating the functional richness and dispersion metrics with the genus-level means.
```

The rest of the week, I developed code for FD calculation using our genus-mean filled trait data. I also finished generating the first null model, using randomly sampled species from the same realm (New World, West Old World or East Old World). This development has sparked plenty of questions, which we can discuss in todays meeting with my daily supervisor.

Questions about FD:
- Standardize FRic to global volume? One issue is that this makes generating null models a little tricky.
- Do single-trait FD with the dbFD function? >>> I have done this, it works fine.
- We should log10-transform traits. However, log(0) is undefined, so we cannot have stem height == 0. Because log10(1) = 0, is it OK to set all the stem.height values to unity? What I ended up doing was converting height and blade length to cm, and fruit length to mm, so that log-transformed values were >0. Then I set the -Inf values (the result of log10(0) to 0.
- The advantage of complete and continuous trait data is that FD can be calculated using a Euclidean distance matrix. Theoretically however (as in, I haven't tried) it should be possible to use data with gaps in the trait matrix (but I suspect it won't work for species with NA for all traits). Is that something worth trying for comparison?
- FRic is probably correlated with species richness. How bad is that and should we use residual FRic instead?
- About the null model: n species sampled randomly from gene pool, where n is the richness in the botanical country. Should that procedure be repeated, say, 100 times for accuracy? Keep in mind function runtime is LONG.

Residual questions about trait-filling:
- When you say 'test normality of estimate residuals', can we do for all genera taken together, or should we do it for each genus individually? I promise to have a look at this, but this week I have focused on FD calculation.


TODO (among other things):
- Implement real FD calculation, using both filled and unfilled (complete-only?) data.
